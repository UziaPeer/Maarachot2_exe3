# peeruzia@gmail.com

Email: peeruzia@gmail.com  
Id: 318410263

# מטלה מספר 3 - מימוש משחק קו (Coup)

## תיאור כללי

במטלה אני מממש את משחק הקו (Coup) בשפת ++C.  
במשחק יש מספר תפקידים עם יכולות ייחודיות, ממשק לניהול תורות, חוקים שונים (כמו הפיכה, מעצר, שוחד וכו') והגדרות מחמירות של תנאים וחריגות לפי חוקי המשחק.

הקוד כתוב בצורה מודולרית ומבוסס על ירושה, כלל השלושה וניהול זיכרון בטוח.  
לצורך ההדגמה נוספה גם המחשה טקסטואלית (`Demo.cpp`) + ממשק גרפי בסיסי (לפי דרישות המטלה).

הקוד רץ בסביבת **Linux** עם `make`.

---

## מבנה התיקיות

- `src/` – קבצי המקור: מימוש המחלקות `Player`, תתי-תפקידים (`Governor`, `Spy`, `Baron`, `General`, `Judge`, `Merchant`), מחלקת `Game` והלוגיקה של ניהול המשחק.
- `include/` – קבצי Header של כל המחלקות.
- `test/` – בדיקות יחידה עם `doctest`.
- `Demo.cpp` – קובץ הדגמה שמדגים שימוש במחלקות.
- `Makefile` – קובץ פקודות לקימפול והרצה.
- `README.md` – תיעוד הפרויקט.

---

## פונקציות ותפקידים עיקריים

### Game
- `turn()` – מחזיר את שם השחקן שבתורו לשחק כעת.
- `players()` – מחזיר רשימה של שמות השחקנים שעדיין פעילים.
- `winner()` – מחזיר את שם המנצח אם נותר שחקן יחיד, אחרת זורק חריגה.

### Player (אבסטרקטי)
- פעולות בסיסיות לכל שחקן:  
  - `gather()` – איסוף מטבע אחד.
  - `tax()` – קבלת שני מטבעות.
  - `bribe()` – תשלום 4 מטבעות לתור נוסף.
  - `arrest(Player& other)` – לקיחת מטבע משחקן אחר.
  - `sanction(Player& other)` – חסימת פעולות כלכליות של שחקן אחר.
  - `coup(Player& other)` – הדחת שחקן מהמשחק.
  - `coins()` – כמות המטבעות של השחקן.
  - `markAction()` – סמן ביצוע פעולה בתור.

### תפקידים ייחודיים
- **Governor** – `tax` משופר (3 מטבעות), יכול לבטל tax של שחקנים אחרים (`undo`).
- **Spy** – יכול לראות כמות מטבעות של שחקן אחר (`track`) ולחסום arrest.
- **Baron** – יכול `invest` (להשקיע) 3 מטבעות ולקבל 6, מפוצה על sanction.
- **General** – יכול למנוע `coup` תמורת 5 מטבעות, מקבל בחזרה arrest.
- **Judge** – יכול לבטל `bribe` של שחקן אחר, גורם לתשלום נוסף ב-sanction.
- **Merchant** – מקבל מטבע אוטומטי אם יש לו לפחות 3 מטבעות בתחילת תורו, משלם פיצוי שונה על arrest.

---

## מטרות המטלה

- ירושה רגילה וירושה וירטואלית.
- שימוש ב-Rule of Three: בנאי העתקה, אופרטור השמה ומפרק עבור ניהול זיכרון.
- ניהול תורות בין שחקנים.
- ניהול חריגות למצבים לא חוקיים.
- בדיקות מקיפות עם `doctest`.
- בדיקת זיכרון עם `valgrind`.

---

## הרצה וקימפול

- `make Main` – קימפול והרצת קובץ ההדגמה (`Demo.cpp`).
- `make test` – קימפול והרצת בדיקות היחידה.
- `make valgrind` – בדיקת נזילות זיכרון.
- `make clean` – ניקוי קבצים זמניים.

---

## בדיקות

הבדיקות בוצעו עם `doctest` (נמצא ב-`include`).  
כוללות בדיקות על:
- מעבר תורות.
- פעולות חוקיות ובלתי חוקיות.
- חריגות תקינות.
- בונוסים ייחודיים של כל תפקיד.
- מימוש נכון של חוקים כמו arrest כפול, חובה לבצע coup עם 10 מטבעות וכו'.

---

## זיכרון

נבדק עם `valgrind`. לא נמצאו דליפות זיכרון.

---

## ממשק גרפי

בפרויקט נוסף ממשק גרפי בסיסי להצגת מצב המשחק דרך אותו המסך, בהתאם לתור השחקן.  
המימוש עושה שימוש בספרייה פשוטה (`SFML`/`QT` לפי זמינות) או הדמיה טקסטואלית.

---






 כלל השלושה (Rule of Three)
בפרויקט זה מימשתי את כלל השלושה בתוך המחלקה Player.
הוספתי:

Copy constructor שמעתיק את כל השדות של השחקן (שם, תפקיד, מצב מטבעות, דגלים פנימיים).

Copy assignment operator שמעתיק את כל השדות במקרה של השמה בין שחקנים.

Destructor מותאם אישית שמוגדר בקובץ Player.cpp ומבצע פינוי מסודר (למרות שאין כאן משאבים דינמיים בפועל).

הדסטרקטור הבסיסי היה virtual ~Player() = default; כדי לאפשר מחיקה דרך מצביע בסיס, וכעת נוסף גם מימוש מפורש להדגמת הכלל.

המטרה: להראות הבנה של ניהול משאבים, ירושה נכונה ב־C++, וניהול חיים של אובייקטים באופן מפורש — גם אם אין ניהול new/delete בפועל.

דוגמה לבדיקה
ב־test.cpp מופיעות בדיקות שמדגימות העתקה של שחקן (Player p2 = p1;) והשמה (p2 = p1;) — וכך אני מראה שכלל השלושה עובד תקין בפרויקט.

